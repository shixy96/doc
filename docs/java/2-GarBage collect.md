# 垃圾回收

- 堆和方法区

- 哪些内存需要回收

- 什么时候回收

- 如何回收



#### 判断对象是否被引用？

- 引用计数法：很难解决对象之间的相互循环引用问题

- 根搜索算法(GC Roots Tracing)：通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连时，则证明此对象是不可用的。

  可作为GC Roots的对象

  - 虚拟机栈（栈帧中的本地变量表）中的引用对象
  - 方法区中的类静态属性引用的对象
  - 方法区中的常量引用的对象
  - 本地方法栈中JNI（Native方法）的引用的对象

  

#### 引用（强度依次减弱）

1. 强引用

2. 软引用，用来描述一些还有用，但非必需的对象。在内存溢出前可进行第二次回收

3. 弱引用，用来描述非必需对象，关联的对象只能生存到下一次垃圾收集发生之前

4. 虚引用，目的是希望在这个对象被回收时收到一个系统通知



#### 判断对象是否需要被回收

1. 根搜索算法不可达，第一次标记
2. 筛选，即此此对象是否有必要执行 finalize 方法，当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，判定为没有必要执行
   - 任何一个对象的 finalize 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize 方法不会被再次执行。

3. 如筛选后有必要执行 finalize 方法，该对象将被放置在一个 F-Queue 的队列中，稍后由低优先级的 Finalizer 线程去触发这个方法，但并不承诺等待他运行结束。
4. GC 对 F-Queue 中的对象进行第二次小规模标记，对没有与引用链上的任何一个对象建立联系的对象进行标记，这些对象将被 GC 回收。



#### 判断一个类是否是无用的类（方法区）

1. 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例
2. 加载该类的 ClassLoader 已经被回收
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法



#### 垃圾收集算法

1. 标记 - 清除算法（Mark-Sweep）

   标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

   缺点：

	- 效率不高
   - 空间问题，标记清除后会产生大量不连续的内存碎片

2. 复制算法（Copying）

   将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块用完了，就将还存活的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。新生代大多采用这种收集算法（8Eden + 1Survivor + 1Survivor）

   缺点：

   - 将内存缩小为原来的一半
   - 对象存活率较高时，效率会变低

3. 标记 - 整理算法（Mark-Compact）

   标记出所有需要回收的对象，在标记完成后将所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

4. 分代收集算法

   根据对象的存活周期不同将内存划分为几块，一般把 Java 堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代采用复制算法，老年代采用标记-清理或者标记-整理算法。



#### 垃圾收集器 —— 内存回收的具体实现

- **Serial** 收集器（新生代）

  新生代采用复制算法。

  - 单线程，在进行垃圾回收时，必须暂停其他所有的工作线程，直到收集结束。

  - 简单高效，在用户桌面应用场景中，分配给虚拟机管理的内存不会很大，收集几十、一两百兆的新生代，停顿时间可以控制在几十毫秒内，对于运行在Client模式下的虚拟机来说是一个很好的选择。

- **ParNew** 收集器（新生代）

  Serial 收集器的多线程版本，能与 CMS 收集器配合工作

- **Parallel Scavenge** 收集器（新生代）

  多线程，新生代采用复制算法，达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。

  特点：自适应调节策略 —— 设置 -XX:+UseAdaptiveSizePolicy, -Xmx, MaxGCPauseMillis, GCTimeRatio，其他参数由虚拟机调节完成。

- **Serial Old** 收集器（老年代）

  老年代采用标记 - 整理算法，主要用于Client模式下的虚拟机使用，或在Server模式下搭配Parallel Scavenge 收集器或者作为CMS收集器的后备预案。

- **Parallel Old** 收集器（老年代）

  Parallel Scavenge 收集器的老年代版本，使用多线程 + 标记-整理。

- **CMS**(Concurrent Mark Sweep) 收集器

  以获取最短回收停顿时间为目标的收集器，使用标记 - 清除算法。

  - **初始标记**

    标记GC Roots 能直接关联到的对象，stop the world

  - **并发标记**

    GC Roots Tracing

  - **重新标记**

    修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短

  - **并发清除**

  **缺点**：

  1. 对 CPU 资源非常敏感
  2. 无法处理浮动垃圾，可能出现 “Concurrent Mode Failure”失败而导致另一次Full GC的产生
  3. 产生大量空间碎片

- **G1** 收集器

收集器参数总结

