# Code Complete

#### Chapter 2. Metaphors for a Richer Understanding of Software Development

将问题概念化 conceptualizing

writing code(extra, like paper, line width, paragraph in clean code); 

给机器运行，给人看，可读性很重要

else metaphors...

#### Chapter 3. Measure Twice, Cut Once: Upstream Prerequisites

前期准备，“Be sure you know what you're aiming at before you shoot”

越早发现问题，解决问题的成本越低；需求变更

关于架构 (3.5, more carefully)

- 资源管理、性能（数据库连接、线程、内存、速度）
- 安全性（防御式编程chapter 8，制定编码规范）
- 拓展性
- **错误处理**（代码规约）
- 容错
- 过度工程（健壮性的统一，代码风格）

Be wary of "we've always done it that way" justifications.

#### Chapter 4. Key Construction Decisions

- Programming Conventions，通过规约解决一些不必要的问题
  - [阿里巴巴Java开发手册](https://github.com/alibaba/p3c)
  - [IntelliJ IDEA plugin](https://github.com/alibaba/p3c/blob/master/idea-plugin)

- quality
  - test，unit test (order)，review

#### Chapter 5. Design in Construction

复杂度失控是项目由技术原因失败的主要原因，系统极度复杂，改动一处代码就能引起不可知的负面影响。

分解、专注、抽象是一部分解决办法，写出自己容易理解，被人容易看懂，很少有错误的代码。

##### 5.2 Key Design Concepts

设计应该有的特征

- 最小的复杂度：不要自作聪明，正确的设计往往简单且易于理解
- 易于维护
- 松耦合：合理抽象、封装
- 可拓展
- 可重用
- high fan-in：utility classes
- Low-to-medium fan-out：减少其他类依赖

- 可移植
- 精简：“It's easy, so what will we hurt by putting it in?”
- 层次化
- 使用标准技术

设计的层次

1. 软件系统，从子系统或者包层次考虑
2. 子系统，设计不同子系统之间通信规则，规则清晰统一，易于维护拓展，没有循环引用
3. 子类
4. 子程序，有层次地组织
5. 子程序内部设计

##### 5.3 Design Building Blocks: Heuristics

**面向对象**的思想，封装属性和方法

合理抽象，封装细节，隐藏底层，统一入口

用常见的设计模式来启发你的设计，不要为了设计模式而让你的代码去套设计模式

设计时应考虑职责分配、模块化、测试方便性等

##### 5.4 Design Practices

重复试验

分而治之

top-down & bottom-up



#### Chapter 6. Working classes

##### 6.1 抽象

使用抽象数据类型隐藏细节、封闭改动、定义明确、减少复杂度

好的类接口应该有好的抽象，职能专一、层次一致、定义明确，与类、接口抽象不一致的属性、方法不应该加进来，考虑将它们放到合适的地方，保证抽象的完整。

##### 6.2 封装：

- 尽可能限制类和成员的可访问性
- 尽可能不公开暴露成员数据
- 避免把具体实现的细节放入类的接口
- 保持接口的抽象一致
- 不要为开发时的方便而降低代码可读性和破坏类接口抽象的完整性
- 保证封装的语义完整性
- 避免过于紧密的耦合关系

##### 6.3 设计实现的问题

1. 包含（has a）

   ​	通过包含来实现“有一个”的关系，并警惕有超过约7个数据成员的类，考虑分解为几个更小的类。

2. 继承（is a）

   ​	继承的**目的**是，通过“定义能为两个或更多个子类提供共有元素的父类”的方式写出更精简的代码。其中的共有元素可以是子类接口、内部实现、数据成员或数据类型等。避免出现重复的代码和数据。

   实现的考虑：

   - 成员变量：对子类可见吗？

   - 成员函数：对子类可见吗？应该有默认实现吗？能被覆盖吗？

   ​	父类中定义的所有函数，用在其子类中时的含义应该都是相同的，即语义相同。

   ​	子类中的成员函数不要与基类中不可覆盖的成员函数重名。

   ​	子类重写了父类的某个函数，但是其中没有任何操作，这种情况最可能是概念的混乱，不应该在子类中覆盖函数，而应该在父类中将该函数的行为、数据抽象到一个具体的类中并让父类包含他。

   ​	继承层次的可接受范围是2到3层，子类的总数应限制在7个左右。过深的继承增加复杂度，导致错误率的增长。

   ​	继承会破坏封装，如果子类需要访问基类的属性，就应该提供 protected 访问器函数。

   ##### tips：

   - 如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象
   - 如果多个类共享行为而非数据，应该让他们从共同的父类继承而来，并在父类里定义共用的成员函数
   - 如果多个类既共享也共享行为，应该让他们从一个共同的父类继承而来，并在父类中定义更用的数据和函数
   - 当你想由父类控制接口时，使用继承；当你想自己控制接口时，使用包含

   尽量减小类和类之间的耦合关系，类中的成员函数和成员变量的数量尽可能少，对外暴露的数量尽可能少，直接调用其他类的函数的次数尽可能少，间接调用其他类函数的次数尽可能少。

##### 6.4 创建类的原因

​	创建类的原因很多，包括为现实世界中的对象建模、为抽象的对象建模、降低复杂度、隔离复杂度、隐藏实现细节、限制变动的影响范围、隐藏全局数据、让参数传递更顺畅、建立中心控制点、包装相关操作、重构复用等。

​	但应该避免创建万能的类、只有数据没有行为的类、只有行为没有数据的类，考虑是否有更好的方式组织结构。

#### Chapter 7. High-Quality Routines

##### 7.1 合适的创建子程序的理由

​	创建子程序的作用是降低复杂度、引入中间、易懂的抽象、避免代码重复、支持子类化、隐藏顺序、隐藏指针操作、提高可移植性、简化复杂的布尔判断、改善性能。

​	不要因为代码段过于简单而否定抽成子程序的行为，子程序使代码更有可读性、更易于拓展。

##### 7.2 在子程序层上设计

​	对子程序而言，内聚性是指子程序中各种操作之间联系的紧密程度，简单而言，极端内聚的子程序只把一件事做好，不再做任何其他事情。内聚性高的子程序可以极大地降低错误的概率。

内聚性的层次：

- 功能的内聚性：一个子程序只执行一项操作，命名往往与行为一致；

不可取的内聚性

- 顺序上的内聚性：子程序包含按特定顺序完成的步骤，之间共享数据，全部完成后完成完整功能 ->抽成不同功能的子程序；
- 通信上的内聚性：子程序包含不同操作，之间共享数据，没有其他联系；
- 临时的内聚性：功能不明确
- 过程上的内聚性
- 逻辑上的内聚性：很大的if或switch，通过标志参数选择性执行 or 事件处理器
- 巧合的内聚性

##### 7.3 好的子程序名字

- 描述子程序所做的所有事情

- 避免使用无意义的、模糊或表述不清的动词

- 不要仅通过数字来形成不同的子程序名字

- 根据需要确定子程序名字的长度（变量9～15）

- 给函数命名时要对返回值有所描述

- 给过程起名时使用语气强烈的动词加宾语的形式

- 准确使用对仗词

- 为常用操作确立命名规则

##### 7.4 子程序能写多长

​	用子程序的内聚性、嵌套层次、变量数量、决策点数量、解释子程序用意所需注释长度等决定子程序长度，但一般不超过200行。

##### 7.5 如何使用子程序参数

​	子程序调用传参错误在程序的错误中会占很大比例，参考一下原则减少接口调用错误。

- 按照输入-修改-输出的顺序排列参数
- 如果几个子程序都用了类似的一些参数，应该让这些参数排列的顺序保持一致
- 使用所有参数，不使用的参数应该从接口中删去
- 把状态或出错变量等指示性变量放在最后
- 不要把子程序的参数用作工作变量
- 在接口中对参数的假定加以说明
- 把子程序的参数限制在大约7个以内
- 考虑对参数采用某种表示输入、修改、输出的命名规则
- 为子程序传递用以维持其接口抽象的变量或对象
- 使用具名参数
- 确保实际参数与形式参数相匹配

#### Chapter 8. Defensive Programming

​	防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏。

- 检查所有来源于外部的数据的值
- 检查所有子程序所有输入参数的值
- 决定如何处理错误的输入数据

##### 8.2 断言

​	断言是指在开发期间使用的、让程序运行时进行自检的代码，主要是用于开发和维护阶段。可以用断言检查像如下的假定：

- 输入参数或输出参数的取值处于预期的范围内
- 文件流状态
- 指针非空

​    使用断言的建议：

- 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况，即断言用于检查代码中的bug。不能依赖断言来让代码正常工作，一旦触发了断言需要修改代码并重新发布。

- 避免把需要执行的代码放到断言中。

- 用断言来注解并验证契约式编程中的前条件和后条件。
- 对于高健壮性的代码，应该优先使用断言再处理错误。

##### 8.3 错误处理技术

- 返回中立值
- 换用下一个正确的数值
- 返回与前次相同的数据
- 换用最接近的合法值
- 把警告信息记录到日志文件中
- 返回一个错误码
- 调用错误处理子程序或对象
- 当错误发生时显示出错消息
- 局部处理错误
- 关闭程序

应该在整个程序里采用一致的方法处理非法的参数，对正确性和健壮性要合理取舍

##### 8.4 异常

- 用异常通知程序的其他部分，发生了不可忽略的错误
- 只在真正例外的情况下才会抛出异常
- 不要将能在局部处理的错误当作异常抛出
- 在恰当的抽象层次抛出异常
- 在异常消息中加入关于导致异常发生的全部信息
- 避免使用空的catch语句
- 了解所用函数库可能抛出的异常
- 考虑创建一个集中的异常报告机制
- 把项目中对异常的使用标准化

##### 8.5 隔离程序使之包容由错误造成的损害

​	把某些接口选定为安全区域的边界，对穿越安全区域边界的数据进行合法性校验，当数据非法时作出反应。比如，在输入数据时将其转化为恰当的类型

##### 8.6 辅助调试的代码

- 应该在开发期间牺牲一些速度和对资源的使用，来换取一些可以让开发更顺畅的内置工具
- 采用进攻式编程，在开发阶段把异常显现出来，产品上能够自我恢复；可以把产品异常发送到邮件以便了解还有哪些错误

##### 8.7 确定在产品中该保留多少防御式代码

- 保留那些检查重要错误的代码
- 去掉检查席位错误的代码
- 去掉会导致程序硬性崩溃的代码
- 保留可以让程序稳妥地崩溃的代码
- 友好地记录错误信息

##### 8.8 对防御式编程采取防御的姿态

​	适度地进行防御式编程

#### Chapter 9. The Pseudocode Programming Process

##### 9.1 创建类和子程序的步骤概述

##### 类

- 创建类的总体设计：职责、暴露接口、继承、暴露数据
- 创建类中的子程序
- 测试

##### 子程序类似

##### 9.2 伪代码

​	建议：

- 用类似英语的语句来精准描述特定的操作
- 避免使用目标编程语言中的语法元素
- 在本意上编写伪代码
- 在一个足够低的层次上编写伪代码，以便生成目标代码

##### 9.3 通过伪代码编程过程创建子程序

- 设计子程序
  - 检查先决条件
  - 定义要解决的问题
  - 命名
  - 决定如何测试
  - 在已有库函数中搜索可用功能
  - 错误处理
  - 效率
  - 算法和数据类型
  - 编写伪代码
  - 考虑数据
  - 检查伪代码
  - 迭代

##### 9.4 伪代码编程过程的替代方案

- 测试驱动
- 重构
- 契约式设计



#### Chapter 10. General Issues in Using Variables

##### 10.3 变量初始化原则

- 在声明变量的时候初始化
- 在靠近变量第一次使用的位置初始化
- 尽量在靠近第一次使用变量的位置声明和定义该变量
- 在可能的情况下使用 final 或者 const
- 特别注意计数器和累加器值的重置
- 在类的构造函数里初始化数据
- 检查是否需要重新初始化
- 检查输入参数的合法性

##### 10.4 作用域

​	尽量避免使用全局变量，变量引用局部化，把变量的引用点尽可能集中在一起，提高可读性；尽可能缩短变量的存活时间，减少攻击窗口。

​	减小作用域的一般原则

- 在循环开始之前再去初始化该循环里使用的变量
- 直到变量即将被使用时再为其赋值
- 把相关语句放在一起，可以提成单独的子程序
- 开始时采用最严格的可见性，然后根据需要拓展变量的作用域

##### 10.6 变量的赋值时间

1. 编码时（魔术字）
2. 编译时（具名常量）
3. 加载时（从外部数据源读取数据）
4. 对象实例化时
5. 即时

一般而言，变量值的绑定时间越早灵活性越差，但复杂度也会越低。

##### 10.7 为变量指定单一用途

​	每个变量只用于单一用途，避免让代码具有隐含含义，确保使用了所有已声明的变量

#### Chapter 11. The Power of Variable Names

##### 11.1 选择好变量名的注意事项

​	以问题为导向，对变量的适当长度的描述通常是最佳的变量名。避免使用过短的变量名。

​	类似Total、Sum、Max等表示计算结果的限定词应该放在名字的最后（避免num，用index/total），提高代码的一致性。

##### 11.2 为特定类型的数据命名

##### 为状态变量命名

​	取一个比flag更好的名字，应该用枚举类型、具名常量，要去猜测意义的代码需要考虑重新命名。

##### 为临时变量命名

​	避免temp

##### 为布尔变量命名

​	done、error、found、success等隐含真假含义的名字是不错的选择，避免status，使用肯定的布尔变量

##### 11.6 创建具备可读性的短名字

- 使用标准缩写
- 去掉虚词
- 去掉无用后缀

缩写要一致

##### 11.7 应该避免的名字

- 避免使用令人误解的名字或缩写
- 避免使用具有类似含义的名字
- 避免使用具有不同含义但名字相似的变量
- 避免使用发音相似的名字
- 避免在名字中使用数字
- 避免拼写错误
- 避免使用仅用大小写区分的变量
- 避免使用关键字

#### Chapter 12. Fundamental Data Types

避免魔术字的出现

检查整数除法、溢出，浮点数精度

#### Chapter 15. Using Conditionals

##### 15.1 if

首先写正常代码路径，再处理不常见情况；利用布尔函数调用简化复杂的检测。

##### 15.2 case

​	case的排列顺序可以按字母顺序或数字顺序排列，也可以把正常的情况放在前面，还可以按执行频率排列。

- 简化每种情况对应的操作
- 不要为了使用case语句刻意造一个变量
- default只用于默认情况而不是最后一种情况
- 利用default检测错误
- break or comment at the end of case



#### Chapter 16. Controlling Loops

​	把初始化代码紧放在循环前面，避免空循环，一个循环只做一件事，不应该包含很多break，在嵌套循环中使用有意义的变量名来提高其可读性。

​	循环的长度要尽可能短，把嵌套限制在3层以内，把长循环的内容移到子程序中。

#### Chapter 17. Unusual Control Structures

​	用防卫子句（早返回/退出）来替代深度嵌套的if语句，减少无意义的return。

​	把递归限制在一个子程序内，确认递归能够停止。递归比循环写出的子程序更难理解，速度更慢，且无法预测运行期间内存使用情况，要用在合适的地方，在用递归之前应该考虑它的替换方案，综合考虑决定。

#### Chapter 18. Table-Driven Methods

​	**表驱动**：从数据表里查找信息替换逻辑语句。怎么从表中查询条目（直接访问，索引访问，阶梯访问）；在表里面存什么数据。

##### 直接访问表

``` java
Integer[] dayPerMonth = new Integer[]{31, 28, 31};
days = dayPerMonth[month - 1];
```

```java
abstract class Field {void print();}
class StringField extends Field {fields...}
class IntegerField extends Field {fields...}
...
Field[] fields = new Field{
  new StringField(),
  new IntegerField(),
  ...
}
for(records){
  fields[record.getIndex()].print();
}
```

​	可以将构造查询表键值抽取成独立的子程序，利用hash或者其他方法生成独一无二的键值。

##### 索引访问表

​	当键值无法通过简单的运算得到或者主查询表中每一条记录都很大时，可以考虑建立索引表，使查询更方便，更可维护。

##### 阶梯访问表

​	表中的数据对不同的数据范围有效，通过范围归类（eg: 40%, 80%, 100%）。使用时小心边界值的归属，表很大时考虑二分搜索，如果更注重性能时考虑使用索引访问表。

#### Chapter 19. General Control Issues

##### 布尔表达式

​	拆分复杂的判断并引入新的布尔变量，把复杂的表达式做成布尔函数并取一个好的名字；用决策表代替复杂条件判断。

​	在if语句中，尽量使用肯定的判断条件，并放在开头，便于理解，或者给变量名换一个名字；

​	尽量简化布尔表达式，不要使用双重否定；

​	在复杂表达式中添加括号使表意清晰；

​	注意布尔‘短路’，区分不同语言对于布尔求值的实现；

​	按照数轴的顺序编写数值表达式；

​	0在布尔表达式中与数值应该显式地做比较，```while(num != 0)```

​	常量尽量放表达式左边，利用编译检查避免符号错用。

##### 空语句

​	避免使用空语句，如果一定要使用，使用一组空括号来强调空语句。

##### 降低复杂度

​	决策点：代码中出现的if、where、for、and、or、case等关键字。通过决策点来衡量复杂度，尽量让子程序中的决策点<=5，最多不应该超过10。

#### Chapter 20.

##### 	软件质量特性：

- 外在特性：用户关心的特性，比如，正确性、可用性、效率、可靠性、完整性、适应性、精确性、健壮性等
- 内在特性：可维护性、灵活性、可移植性、可重用性、可读性、可测试性、可理解性

定制软件质量目标，明确定义质量保证工作，执行测试为产品进行可靠性评估，交付代码之前检查代码；

在开发过程中，能有效地控制需求变更、设计变更、代码变更，量化开发结果，明确设置质量目标（内存、log、可读性或效率）。

不同质量保障技术的相对效能不同，但是单个效能不会太高，综合运用各种技术，代码检查、单元测试、集成测试、回归测试、系统测试、规模Beta测试等，提高缺陷检测率。

#### Chapter 21. 协同构建

​	协同构建包括结对编程、正式检查、非正式技术复查、文档阅读等让其他人检查自己工作的技术，更快发现错误，缩短开发周期。协同构建使得程序员能够得到关于他们代码的反馈，有助于代码标准的普及。

#### Chapter 22. 开发者测试

​	单元测试、组件测试、集成测试、回归测试、系统测试。测试通常分为两大类：黑盒测试和白盒测试，黑盒测试指测试者无法了解对象内部工作机制，白盒测试则相反。

​	在尽可能早的时候（设计产品的时候）设计测试用例，使用一个检查表，记录在项目到目前为止犯过的错误、在过去项目中犯过的错误类型。

​	首先编写测试用例，将迫使你在开始写代码之前至少思考一下需求和设计。尽可能增加可能让代码失效的测试，而不是检验代码能否工作的测试。

​	测试的窍门在于选择那些最有可能找到错误的测试用例。
