# 并发基础

## 导致问题的因素
> 核心矛盾： *CPU、内存、I/O设备的速度差异*，CPU >> 内存 >> I/O

为了合理利用 CPU 的高性能，平衡者三者的速度差异，计算机体系结构、操作系统、编译程序都做出了不同的贡献：
- CPU 增加了缓存，以均衡与内存的速度差异
- 操作系统增加了进程、线程，分时复用CPU，进而均衡 CPU 与 I/O设备的速度差异
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用

并发程序很多问题的根源也在这里。

### 缓存导致的可见性问题
> 可见性： 一个线程对共享变量的修改，另一个线程能够看到

多核时代，每颗 CPU 都有自己的缓存，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，一个线程在缓存中对变量的修改对于另一个线程来说是不可见的。

### 线程切换带来的原子性问题
> 原子性：一个或多个操作在 CPU 执行的过程中不被中断

高级语言里一条语句往往需要多条 CPU 指令完成，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，任何一条 CPU 指令执行完都可能发生任务切换。

eg. 
1. 当 `线程A` 刚从内存中读取 `变量X`，线程切换到 `线程B`
2. `线程B` 也从内存中读取 `变量X`，进行一些列操作后写入内存
3. 任务切换回 `线程A` 后，`线程A` 继续进行后续操作，但内存中的 `变量X` 已经改变，写回内存会覆盖之前的值。

### 编译优化带来的有序性问题
> 有序性：程序按照代码的先后顺序执行

编译器、解释器为了优化性能，有时候会改变程序中语句的先后顺序，可能会改变程序最终的结果。
```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          // 这里出现了问题
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```
以双重检查创建单例对象为例，new 操作符优化前后的行为发生了改变
1. 分配一块内存 M
2. 将 M 的地址赋给 instance 
3. 在内存 M 上初始化 Singleton 对象

在第二步完成之后，如果发生了线程切换，并且下一个线程也用到了这个单例，后续可能会触发 NPE


## Java 内存模型的解决方法
针对可见性和有序性导致的并发问题的合理解决应该是 `按需禁用缓存` 和 `按需编译优化`。

Java 内存模型规范了 JVM 如何提供`按需禁用缓存`和`编译优化`的方法，包括 `volatile`、`synchronized`、`final` 三个关键字，以及六项 `Happens-Before` 规则。

### volatile
volatile 修饰的变量，不使用 CPU 缓存，必须从内存中读取或写入
### final
final 修饰的变量生而不变（避免构造函数逸出）

### Happens-Before
> 前一个操作的结果对后续的操作是可见的，无论是否发生在同一个线程里。

Happens-Before 约束了编译器的优化行为，要求编译器优化后一定遵守 Happens-Before 规则。
#### 传递性
`A Happens-Before B` & `B Happens-Before C` ==> `A Happens-Before C`
#### 程序的顺序性规则
在一个线程中，按照程序顺序，前面的操作 Happens-Before 后续的任意操作
#### volatile 变量规则
volatile 变量的写操作 Happens-Before 后续对这个 volatile 变量的读操作
#### 管程（synchronized）中锁的规则
对一个锁的解锁 Happens-Before 后续对这个锁的加锁
#### 线程 start 规则
`主线程A`启动`子线程B`的 start 方法，那么 start() 操作 Happens-Before `子线程B` 中的任意操作
#### 线程 join 规则
`主线程A`等待`子线程B`完成（调用 join()），当`子线程B`完成后，`主线程A`能看到`子线程B`的对`共享变量`的操作。

## 解决原子性问题
> 互斥：同一时刻只有一个线程执行
> 临界区：需要护持执行的代码

保证原子性的关键是保证对共享变量的修改是互斥的。
可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。
加锁时，要考虑*锁定的对象*要和被*受保护资源*的关系，确保锁能覆盖所有受保护资源，所有的访问路径都要设置合适的锁。
> 原子性的本质是多个资源间的一致性要求，操作的中间状态对外不可见

### synchronized
Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()。
synchronized 修饰代码块时，锁定了一个对象；修饰静态方法时锁定当前类的 Class 对象；修饰非静态方法时，锁定的是当前实例对象this。

### 细粒度锁
用不同的锁（细粒度锁）对受保护资源进行精细化管理，能够提升性能。但是，使用细粒度锁可能会产生死锁。
> 死锁：一组互相竞争资源的线程因互相等待，导致永久阻塞的现象
死锁产生的条件（只有全部满足才会出现死锁）：
1. 互斥，共享资源 X 和 Y 只能被一个线程占有
2. 占有且等待，线程 T1 已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X
3. 不可抢占，其他线程不能强行抢占线程T1 占有的资源
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源

预防死锁就是破坏死锁产生的条件：
1. 破坏互斥：无法破坏
2. 破坏占有等待：可以一次性申请所有的资源
  - 等待通知机制（类比医院就诊）
    - 线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态(wait)
    - 当线程要求的条件得到满足后，通知等待的线程重新获取互斥锁(notify, *notifyAll*)
    ```java
    while(条件不满足) {
      wait();
    }
    ```
3. 破坏不可抢占：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
4. 破坏循环等待：按序申请资源，申请的时候可以先申请资源序号小的，再申请资源序号大的


