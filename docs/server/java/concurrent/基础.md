# 并发基础

## 导致问题的因素
> 核心矛盾： *CPU、内存、I/O设备的速度差异*，CPU >> 内存 >> I/O

为了合理利用 CPU 的高性能，平衡者三者的速度差异，计算机体系结构、操作系统、编译程序都做出了不同的贡献：
- CPU 增加了缓存，以均衡与内存的速度差异
- 操作系统增加了进程、线程，分时复用CPU，进而均衡 CPU 与 I/O设备的速度差异
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用

并发程序很多问题的根源也在这里。

### 缓存导致的可见性问题
> 可见性： 一个线程对共享变量的修改，另一个线程能够看到

多核时代，每颗 CPU 都有自己的缓存，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，一个线程在缓存中对变量的修改对于另一个线程来说是不可见的。

### 线程切换带来的原子性问题
> 原子性：一个或多个操作在 CPU 执行的过程中不被中断

高级语言里一条语句往往需要多条 CPU 指令完成，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，任何一条 CPU 指令执行完都可能发生任务切换。

eg. 
1. 当 `线程A` 刚从内存中读取 `变量X`，线程切换到 `线程B`
2. `线程B` 也从内存中读取 `变量X`，进行一些列操作后写入内存
3. 任务切换回 `线程A` 后，`线程A` 继续进行后续操作，但内存中的 `变量X` 已经改变，写回内存会覆盖之前的值。

### 编译优化带来的有序性问题
> 有序性：程序按照代码的先后顺序执行

编译器、解释器为了优化性能，有时候会改变程序中语句的先后顺序，可能会改变程序最终的结果。
```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          // 这里出现了问题
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```
以双重检查创建单例对象为例，new 操作符优化前后的行为发生了改变
1. 分配一块内存 M
2. 将 M 的地址赋给 instance 
3. 在内存 M 上初始化 Singleton 对象

在第二步完成之后，如果发生了线程切换，并且下一个线程也用到了这个单例，后续可能会触发 NPE


## Java 内存模型的解决方法
针对可见性和有序性导致的并发问题的合理解决应该是 `按需禁用缓存` 和 `按需编译优化`。

Java 内存模型规范了 JVM 如何提供`按需禁用缓存`和`编译优化`的方法，包括 `volatile`、`synchronized`、`final` 三个关键字，以及六项 `Happens-Before` 规则。

### volatile
volatile 修饰的变量，不使用 CPU 缓存，必须从内存中读取或写入
### final
final 修饰的变量生而不变（避免构造函数逸出）

### Happens-Before
> 前一个操作的结果对后续的操作是可见的，无论是否发生在同一个线程里。

Happens-Before 约束了编译器的优化行为，要求编译器优化后一定遵守 Happens-Before 规则。
#### 传递性
`A Happens-Before B` & `B Happens-Before C` ==> `A Happens-Before C`
#### 程序的顺序性规则
在一个线程中，按照程序顺序，前面的操作 Happens-Before 后续的任意操作
#### volatile 变量规则
volatile 变量的写操作 Happens-Before 后续对这个 volatile 变量的读操作
#### 管程（synchronized）中锁的规则
对一个锁的解锁 Happens-Before 后续对这个锁的加锁
#### 线程 start 规则
`主线程A`启动`子线程B`的 start 方法，那么 start() 操作 Happens-Before `子线程B` 中的任意操作
#### 线程 join 规则
`主线程A`等待`子线程B`完成（调用 join()），当`子线程B`完成后，`主线程A`能看到`子线程B`的对`共享变量`的操作。
